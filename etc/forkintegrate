#!/bin/ksh
#                      forkintegrate
#
# enables  multi-tasking by splitting the INTEGRATE step of
# xds into independent jobs. Each job is carried out by the
# Fortran program mintegrate or mintegrate_par started by
# this script as a background process with a different set
# of input parameters.
#
# 'forkintegrate' is called by xds (or xds_par) in the
# INTEGRATE step using the Fortran instruction
# CALL SYSTEM('forkintegrate fframe ni ntask niba0 maxcpu'),
#    fframe ::id number of the first data image
#    ni     ::number of images in the data set
#    ntask  ::total number of jobs
#    niba0  ::minimum number of images in a batch
#    maxcpu ::maximum number of processors used by each job
#
# Clearly, this can only work if forkintegrate, mintegrate,
# and mintegrate_par are correctly installed in the search
# path for executables.
#
# W.Kabsch and K.Rohm     Version Februar 2005
# NOTE: No blanks allowed adjacent to the = signs !!!

# K.Diederichs 9/2005 modification of this script make job
# execution on remote hosts work in networked (NFS) environment.
# The list of hosts where the jobs should run, of course, needs
# to be adapted to each installation.

# This has since been modified to run on a new cluster, using qsub
# do it could be kinda messy. You have been warned. Based on a script
# provided by Frederik Ferner:
# 
# 11022001 AWA extended to cope with only gda allowed to use the high.q
#
# cat $PE_HOSTFILE

install=/dls_sw/apps/XDS/26sep2012-64

if test "$FORKINTEGRATE_QUEUE" = "high" ; then
    if test $USER = 'gda' ; then
	queue=high.q
    elif test $USER = 'gda2' ; then
	queue=high.q
    else
	queue=medium.q
    fi
else
    queue=medium.q
fi

fframe=$1 #id number of the first image
ni=$2     #number of images in the data set
ntask=$3  #total number of jobs
niba0=$4  #minimum number of images in a batch
maxcpu=$5 #maximum number of processors used by each job
          #maxcpu=1: use 'mintegrate' (single processor)
          #maxcpu>1: use 'mintegrate_par' (openmp version)

minitask=$(($ni / $ntask)) #minimum number of images in a job
mtask=$(($ni % $ntask))    #number of jobs with minitask+1 images
pids=""                    #list of background process ID's
nba=0
litask=0
itask=1
while test $itask -le $ntask
do
   if [ $itask -gt $mtask ]
      then nitask=$minitask
      else nitask=$(($minitask + 1))
   fi
   fitask=`expr $litask + 1`
   litask=`expr $litask + $nitask`
   if [ $nitask -lt $niba0 ]
      then n=$nitask
      else n=$niba0
   fi
   if [ $n -lt 1 ]
      then n=1
   fi
   nbatask=$(($nitask / $n))
   nba=`expr $nba + $nbatask`
   image1=$(($fframe + $fitask - 1)) #id number of the first image

   if [ $maxcpu -gt 1 ]
      then qsub -sync y -V -q $queue -l h_rt=0:20:00 -cwd -pe smp 8 \
	  ${install}/forkintegrate_job \
	  $image1 $nitask $itask $nbatask &
      else echo "$image1 $nitask $itask $nbatask" | qrsh -V -q $queue -cwd "mintegrate"     &
   fi
   pids="$pids $!"  #append id of the background process just started

   itask=`expr $itask + 1`
done
trap "kill -15 $pids" 2 15  # 2:Control-C; 15:kill
wait  #wait for all background processes issued by this shell
rm -f mintegrate.tmp  #this temporary file was generated by mintegrate


